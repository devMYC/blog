---
title: Try to understand Monad, again.
publish_date: TBD (PST)
abstract: Monad? Maybe.
---

> Disclaimer: Contents below are my own understanding on the topic discussed. They might be correct
> or wrong. Take my words with a grain of salt and feel free to point out the mistakes.

Coming from an Object-Oriented Programming (OOP) background. I still remember the very first time
I was exposed to Functional Programming (FP). My mind was blown after seeing people define small
functions and compose them in different ways to get different results while keeping the code elegant
and easy to read. I had absolutely no idea why things worked together magically. But I felt like it
opened a door to a whole new world in which people reason about programs with a totally different
mental model. After reading the book [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://mostly-adequate.gitbook.io/mostly-adequate-guide/#about-this-book)
by Brian Lonsdorf (a.k.a. Dr Boolean). I got a basic understanding of how things work under the hood
and I started experimenting some of those techniques in the codebase I worked with back then.
It made things deterministic and easy to test when you know all these functions that are used to
compose a new function are _pure_ functions. And I was really happy with the result I achieved using
the knowledge I acquired from another programming paradigm. But still there's one thing that I hear
FP people talk about a lot and I don't quite understand what it is: Monad.

In order to understand Monad, I even took a functional programming course which was taught using
Haskell during my Master's program. Although I was able to complete the assignments when we focused
on the topic of Monad for those ~2 weeks during the semester. But the explanation given by the instructor
still didn't turn on the lightbulb in my head. After taking the course, all I know about Monad is
merely that we need to implement the Functor, Applicaive, and Monad interfaces (or typeclasses shown below)
and we can write code using the do-notation. But I still don't know _why_ and _when_ we should make things monadic.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b


class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b


class Applicative m => Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
```

Recently, I've been trying to refresh my memory on parsing algorithms and techniques. Then I remember
that we were implementing a monadic parser for one of the assignments in that Haskell course back in
school. So I decided to give another try to understand Monad. Luckily, this time I found lectures from
professor [Graham Hutton](http://www.cs.nott.ac.uk/~pszgmh/) on Youtube about advanced FP topics in Haskell.
The videos focusing on Monad give some good examples of why and when Monad is needed, and I would say
they are the best videos I've seen explaining Monad. Let's start with _why_ Monad is useful using the
example from the lecture.

Consider that we will be evaluating expressions of divisions between integers. An expression can be
represented by the following recursive data type.

```haskell
data Expr = Val Int
          | Div Expr Expr
```

Then a function to evaluate an expression can be defined like this:

```haskell
eval :: Expr -> Int
eval (Val n) = n
eval (Div e1 e2) = eval e1 `div` eval e2
```

As you can see this function will throw divide-by-zero exception when `eval e2` returns zero.
To represent failure in a pure functional language like Haskell. We need a special type to indicate
something could fail. Haskell has a built-in `Maybe` type (shown below) that can be used in this situation.

```haskell
data Maybe a = Nothing  -- failure with no result
             | Just a   -- success with result `a`
```

Then we can create a safe version of `div` and rewrite our `eval` function like this:

```haskell
safediv :: Int -> Int -> Maybe Int
safediv _ 0 = Nothing
safediv x y = Just (x `div` y)


eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div e1 e2) =
    case eval e1 of
        Nothing -> Nothing
        Just x ->
            case eval e2 of
                Nothing -> Nothing
                Just y -> safediv x y
```

A key notion mentioned in the lecture is that _Monad is about observing common pattern_.
And here the pattern in `eval` is that we have to check the result of `eval` using `case-of` branches
for both sub-expressions of `Div Expr Expr`. Let's extract this common pattern to an infix function
named `>>=`.

```haskell
mx >>= f =
    case mx of
        Nothing -> Nothing
        Just x -> f x
```

So what is the type of `>>=`? We can infer the type based on the implementation.
Because we are matching `mx` against `Nothing` and `Just`, we know `mx` must be a `Maybe` type of
something (i.e. `Maybe a`). Since we are passing the inner value `x` of `Just x` to `f`.
Then we know `f` takes a parameter of the same type as `x`. What should be the result type of `f x`?
Because both case branches must return the same type. Therefore, `f x` is also a `Maybe` type of
something (i.e. `Maybe b` which means it might not contain a inner value of the same type as `x`).
With our analysis, we can finally tell that this function has type `(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b`.
Let's rewrite our `eval` again using this helper function `>>=`.

```haskell
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div e1 e2) = eval e1 >>= \x ->
                   eval e2 >>= \y ->
                   safediv x y
```

This can be generalized to any number of parameters as follows:

```
m1 >>= \arg1 ->
m2 >>= \arg2 ->
    .
    .
    .
mn >>= \argn ->
f arg1 arg2 ... argn
```

We will only get our final result if every argument to `f` is obtained successfully. A failure during
the process will terminate the computation early and the whole thing will just evaluate to `Nothing`.
This is similar to propagating an exception in OOP languages like Java using `throw` statement.
In fact, this pattern is common enough so Haskell even has a syntactic sugar for it known as the `do`-notation.

```
do arg1 <- m1
   arg2 <- m2
       .
       .
       .
   argn <- mn
   f arg1 arg2 ... argn
```

Let's rewrite our implementation using the `do`-notation.

```haskell
eval :: Expr -> Maybe Int
eval (Val n) = Just n
eval (Div e1 e2) = do x <- eval e1
                      y <- eval e2
                      safediv x y
```

You probably have already noticed that the function `>>=` defined above has a very similar type as
the `>>=` method defined on typeclass Monad. Actually, `Maybe` type does implement the Monad typeclass
and we can use `>>=` (known as the bind operator) directly without having to define our own implementation.
Try the following in `GHCi` from command line and see if you get same output.

```
$ ghci
λ> Just 10 >>= \n -> Just (n*2)
Just 20
λ> Just 10 >>= \_ -> Nothing >>= \n -> Just (n*2)
Nothing
```

Now we see that Monad can help us "bind" operations together and deal with effects in a pure language.
And we are able to leverage the `do`-notation to improve code readability. The lectures also give
more examples of making other types monadic. Among those examples, I find the state Monad to be a
really good scenario when Monad should be used.



